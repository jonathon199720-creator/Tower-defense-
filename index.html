<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚ö° NEXUS DEFENSE ‚ö°</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

body {
background: #0a0e27;
color: #0ff;
font-family: ‚ÄòCourier New‚Äô, monospace;
height: 100vh;
display: flex;
flex-direction: column;
overflow: hidden;
}

.game-container {
flex: 1;
display: flex;
align-items: center;
justify-content: center;
background: linear-gradient(135deg, #0a1a2e 0%, #16213e 50%, #0f3460 100%);
}

canvas {
display: block;
width: 100%;
height: 100%;
border: 1px solid rgba(0, 255, 255, 0.2);
cursor: crosshair;
}

.panel-container {
height: 130px;
background: rgba(10, 14, 39, 0.95);
border-top: 1px solid rgba(0, 255, 255, 0.3);
display: flex;
align-items: flex-start;
padding: 8px 15px;
gap: 12px;
overflow-x: auto;
}

.panel-section {
background: rgba(10, 14, 39, 0.85);
border: 1px solid rgba(0, 255, 255, 0.4);
padding: 8px 10px;
border-radius: 2px;
display: flex;
flex-direction: column;
gap: 6px;
min-width: max-content;
}

.section-title {
color: #0ff;
font-weight: bold;
font-size: 0.7em;
text-transform: uppercase;
text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

.stats-grid {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 6px;
font-size: 0.75em;
}

.stat-item {
display: flex;
justify-content: space-between;
align-items: center;
gap: 6px;
}

.stat-label {
color: rgba(0, 255, 255, 0.5);
font-size: 0.65em;
}

.stat-value {
color: #0ff;
font-weight: bold;
}

.towers-and-controls {
display: flex;
flex-direction: column;
gap: 0;
background: rgba(10, 14, 39, 0.85);
border: 1px solid rgba(0, 255, 255, 0.4);
border-radius: 2px;
overflow: hidden;
}

.towers-section {
padding: 8px 10px;
border-bottom: 1px solid rgba(0, 255, 255, 0.2);
display: flex;
flex-direction: column;
gap: 4px;
}

.controls-section {
padding: 8px 10px;
display: flex;
flex-direction: column;
gap: 4px;
}

.tower-btn {
padding: 6px 8px;
background: rgba(0, 255, 255, 0.1);
border: 1px solid rgba(0, 255, 255, 0.4);
color: #0ff;
cursor: pointer;
font-family: ‚ÄòCourier New‚Äô, monospace;
font-weight: bold;
font-size: 0.65em;
border-radius: 2px;
white-space: nowrap;
transition: all 0.2s;
}

.tower-btn:hover:not(:disabled) {
background: rgba(0, 255, 255, 0.2);
border-color: #0ff;
}

.tower-btn:disabled {
opacity: 0.2;
cursor: not-allowed;
}

.tower-btn.active {
background: rgba(0, 255, 255, 0.3);
border-color: #0ff;
}

.control-btn {
padding: 6px 10px;
background: rgba(0, 255, 255, 0.1);
border: 1px solid rgba(0, 255, 255, 0.4);
color: #0ff;
cursor: pointer;
font-family: ‚ÄòCourier New‚Äô, monospace;
font-weight: bold;
font-size: 0.65em;
border-radius: 2px;
text-transform: uppercase;
transition: all 0.2s;
}

.control-btn:hover:not(:disabled) {
background: rgba(0, 255, 255, 0.2);
border-color: #0ff;
}

.control-btn:disabled {
opacity: 0.2;
}

.control-btn.danger {
color: #ff007f;
border-color: rgba(255, 0, 127, 0.4);
}

.control-btn.danger:hover:not(:disabled) {
background: rgba(255, 0, 127, 0.1);
border-color: #ff007f;
}

.upgrade-btn {
padding: 4px 6px;
background: rgba(0, 255, 255, 0.1);
border: 1px solid rgba(0, 255, 255, 0.4);
color: #0ff;
cursor: pointer;
font-family: ‚ÄòCourier New‚Äô, monospace;
font-weight: bold;
font-size: 0.6em;
border-radius: 2px;
text-transform: uppercase;
white-space: nowrap;
transition: all 0.2s;
}

.upgrade-btn:hover:not(:disabled) {
background: rgba(0, 255, 255, 0.2);
border-color: #0ff;
}

.upgrade-btn:disabled {
opacity: 0.2;
}

.upgrade-btn.sell {
color: #ff007f;
border-color: rgba(255, 0, 127, 0.4);
}

.upgrade-btn.sell:hover:not(:disabled) {
background: rgba(255, 0, 127, 0.1);
border-color: #ff007f;
}

.tower-mgmt-section {
display: none;
}

.tower-mgmt-section.active {
display: flex;
}

.tower-mgmt-title {
color: #0ff;
font-weight: bold;
font-size: 0.7em;
text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

.tower-mgmt-stat {
color: rgba(0, 255, 255, 0.6);
font-size: 0.6em;
line-height: 1.1;
}

.health-bar {
background: rgba(0, 0, 0, 0.5);
border: 1px solid rgba(0, 255, 255, 0.3);
height: 2px;
border-radius: 2px;
margin: 2px 0;
overflow: hidden;
}

.health-fill {
height: 100%;
background: linear-gradient(90deg, #0f0, #0ff);
transition: width 0.2s;
}

.tower-mgmt-buttons {
display: flex;
flex-wrap: wrap;
gap: 3px;
margin-top: 4px;
}

.message {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0, 255, 255, 0.2);
border: 2px solid #0ff;
color: #0ff;
padding: 12px 20px;
border-radius: 2px;
font-weight: bold;
opacity: 0;
animation: slideIn 0.3s ease forwards, slideOut 0.3s ease 2.7s forwards;
pointer-events: none;
z-index: 1000;
}

.message.success {
border-color: #0f0;
background: rgba(0, 255, 0, 0.1);
color: #0f0;
}

.message.error {
border-color: #ff007f;
background: rgba(255, 0, 127, 0.1);
color: #ff007f;
}

@keyframes slideIn {
from { opacity: 0; transform: translate(-50%, -60%); }
to { opacity: 1; transform: translate(-50%, -50%); }
}

@keyframes slideOut {
to { opacity: 0; transform: translate(-50%, -40%); }
}

.boss-warning {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(255, 0, 127, 0.2);
border: 3px solid #ff007f;
color: #ff007f;
padding: 30px 50px;
font-size: 2em;
font-weight: bold;
z-index: 998;
display: none;
animation: bossWarningPulse 0.6s infinite;
}

.boss-warning.active {
display: block;
}

@keyframes bossWarningPulse {
0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
}

.pause-indicator {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
font-size: 4em;
color: #0ff;
opacity: 0;
pointer-events: none;
z-index: 997;
}

.pause-indicator.active {
animation: pauseFlash 0.5s ease;
}

@keyframes pauseFlash {
0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
50% { opacity: 1; }
100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}
</style>

</head>
<body>

<div class="game-container">
  <canvas id="gameCanvas"></canvas>
</div>

<div class="panel-container">
  <!-- Stats Panel -->
  <div class="panel-section">
    <div class="section-title">üìä STATS</div>
    <div class="stats-grid">
      <div class="stat-item"><span class="stat-label">üí∞</span><span class="stat-value" id="moneyDisplay">500</span></div>
      <div class="stat-item"><span class="stat-label">üåä</span><span class="stat-value" id="levelDisplay">1</span></div>
      <div class="stat-item"><span class="stat-label">üõ°</span><span class="stat-value" id="towersDisplay">0</span></div>
      <div class="stat-item"><span class="stat-label">‚ò†</span><span class="stat-value" id="killsDisplay">0</span></div>
    </div>
  </div>

  <!-- Towers and Controls -->

  <div class="towers-and-controls">
    <div class="towers-section">
      <button class="tower-btn" id="towerBtn0" onclick="selectTower(0)">‚ö° LASER [$150]</button>
      <button class="tower-btn" id="towerBtn1" onclick="selectTower(1)">üí£ CANNON [$200]</button>
      <button class="tower-btn" id="towerBtn2" onclick="selectTower(2)">„Ä∞ PULSE [$180]</button>
    </div>
    <div class="controls-section">
      <button class="control-btn" id="startBtn" onclick="startWave()">‚ñ∂ START</button>
      <button class="control-btn" id="pauseBtn" onclick="togglePause()">‚è∏ PAUSE</button>
      <button class="control-btn danger" onclick="resetGame()">üîÑ RESET</button>
    </div>
  </div>

  <!-- Tower Management -->

  <div class="panel-section tower-mgmt-section" id="towerMgmtPanel">
    <div class="tower-mgmt-title" id="selectedTowerName">-</div>
    <div class="tower-mgmt-stat" id="selectedTowerStats">-</div>
    <div class="health-bar"><div class="health-fill" id="selectedTowerHealth" style="width: 100%;"></div></div>
    <div class="tower-mgmt-stat" id="selectedTowerHealthText">Health: 100/100</div>
    <div class="tower-mgmt-buttons">
      <button class="upgrade-btn" onclick="repairTower()">REPAIR</button>
      <button class="upgrade-btn" onclick="upgradeDamage()">DMG</button>
      <button class="upgrade-btn" onclick="upgradeRange()">RNG</button>
      <button class="upgrade-btn" onclick="upgradeFireRate()">SPD</button>
      <button class="upgrade-btn sell" onclick="sellTower()">SELL</button>
    </div>
  </div>
</div>

<div class="boss-warning" id="bossWarning">‚ö† BOSS INCOMING ‚ö†</div>
<div class="pause-indicator" id="pauseIndicator">‚è∏</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Game state
let money = 500, level = 1, waveActive = false, isPaused = false;
let selectedTowerType = -1, selectedTower = null;
let totalKills = 0, enemiesEscaped = 0;
let waveHasSpawned = false, isBossWave = false, bossWarningTriggered = false;

const towers = [], enemies = [], particles = [];

const TOWER_TYPES = [
  { name: "Laser", cost: 150, color: "#00bfff", damage: 12, range: 120, fireRate: 40, size: 14 },
  { name: "Cannon", cost: 200, color: "#ff8c00", damage: 20, range: 150, fireRate: 60, size: 16 },
  { name: "Pulse", cost: 180, color: "#00ff88", damage: 8, range: 160, fireRate: 25, size: 15 }
];

const ENEMY_TYPES = [
  { name: "Scout", speedMult: 1.1, hpMult: 0.8, rewardMult: 0.8, isBoss: false },
  { name: "Trooper", speedMult: 1.0, hpMult: 1.0, rewardMult: 1.0, isBoss: false },
  { name: "Tank", speedMult: 0.6, hpMult: 1.5, rewardMult: 1.3, isBoss: false },
  { name: "Boss", speedMult: 0.8, hpMult: 3.0, rewardMult: 5.0, isBoss: true }
];

let currentPath = [];

function initCanvas() {
  const container = document.querySelector('.game-container');
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  console.log("Canvas initialized:", canvas.width, "x", canvas.height);
}

function generatePath() {
  const paths = [
    [{ x: canvas.width * 0.5, y: -20 }, { x: canvas.width * 0.5, y: canvas.height * 0.2 },
     { x: canvas.width * 0.2, y: canvas.height * 0.2 }, { x: canvas.width * 0.2, y: canvas.height * 0.56 },
     { x: canvas.width * 0.8, y: canvas.height * 0.56 }, { x: canvas.width * 0.8, y: canvas.height * 0.84 },
     { x: canvas.width * 0.1, y: canvas.height * 0.84 }, { x: canvas.width * 0.1, y: canvas.height + 20 }],
    [{ x: canvas.width * 0.9, y: -20 }, { x: canvas.width * 0.9, y: canvas.height * 0.3 },
     { x: canvas.width * 0.4, y: canvas.height * 0.3 }, { x: canvas.width * 0.4, y: canvas.height * 0.2 },
     { x: canvas.width * 0.1, y: canvas.height * 0.2 }, { x: canvas.width * 0.1, y: canvas.height * 0.7 },
     { x: canvas.width * 0.9, y: canvas.height * 0.7 }, { x: canvas.width * 0.9, y: canvas.height + 20 }]
  ];
  const pathIndex = level <= 5 ? 0 : 1;
  currentPath = paths[pathIndex];
}

function distance(x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

function showMessage(text, type = "success") {
  const msg = document.createElement("div");
  msg.className = "message " + type;
  msg.textContent = text;
  document.body.appendChild(msg);
  setTimeout(() => msg.remove(), 3000);
}

function spawnEnemy(isBoss = false) {
  const type = isBoss ? ENEMY_TYPES[3] : ENEMY_TYPES[Math.floor(Math.random() * 3)];
  const baseHp = isBoss ? (100 + level * 30) : (30 + level * 15);
  
  enemies.push({
    x: currentPath[0].x,
    y: currentPath[0].y,
    hp: baseHp * type.hpMult,
    maxHp: baseHp * type.hpMult,
    speed: (1.5 + level * 0.1) * type.speedMult,
    radius: isBoss ? 18 : 10,
    pathIndex: 0,
    progress: 0,
    type: isBoss ? 3 : (Math.floor(Math.random() * 3)),
    isBoss: isBoss,
    rewardMult: type.rewardMult
  });
}

function selectTower(type) {
  if (money < TOWER_TYPES[type].cost) {
    showMessage("INSUFFICIENT CREDITS", "error");
    return;
  }
  selectedTowerType = type;
  document.querySelectorAll(".tower-btn").forEach(btn => btn.classList.remove("active"));
  document.getElementById("towerBtn" + type).classList.add("active");
}

function startWave() {
  if (waveActive) return;
  generatePath();
  isBossWave = (level % 5 === 0);
  if (isBossWave && !bossWarningTriggered) {
    document.getElementById("bossWarning").classList.add("active");
    bossWarningTriggered = true;
    setTimeout(() => document.getElementById("bossWarning").classList.remove("active"), 3000);
    return;
  }
  
  waveActive = true;
  waveHasSpawned = false;
  enemiesEscaped = 0;
  document.getElementById("startBtn").disabled = true;
  
  let count = 0;
  const enemyCount = isBossWave ? 8 : (5 + level * 2);
  
  const spawnInterval = setInterval(() => {
    if (!isPaused) {
      if (isBossWave && count === 0) {
        spawnEnemy(true);
      } else {
        spawnEnemy(false);
      }
      count++;
      waveHasSpawned = true;
    }
    if (count >= enemyCount) clearInterval(spawnInterval);
  }, isBossWave ? 300 : 600);
}

function togglePause() {
  if (!waveActive) { showMessage("START A WAVE FIRST", "error"); return; }
  isPaused = !isPaused;
  document.getElementById("pauseBtn").textContent = isPaused ? "‚ñ∂ RESUME" : "‚è∏ PAUSE";
}

function resetGame() {
  if (confirm("RESET ALL PROGRESS?")) {
    money = 500; level = 1; totalKills = 0; waveActive = false;
    towers.length = 0; enemies.length = 0;
    document.getElementById("startBtn").disabled = false;
    document.getElementById("pauseBtn").textContent = "‚è∏ PAUSE";
    showMessage("SYSTEM RESET", "success");
  }
}

function selectTowerOnCanvas(tower) {
  selectedTower = tower;
  document.getElementById("towerMgmtPanel").classList.add("active");
  document.getElementById("selectedTowerName").textContent = `${TOWER_TYPES[tower.type].name.toUpperCase()}`;
  document.getElementById("selectedTowerStats").textContent = `DMG: ${tower.damage} | RNG: ${tower.range}`;
  document.getElementById("selectedTowerHealthText").textContent = `Health: ${tower.health}/${tower.maxHealth}`;
  document.getElementById("selectedTowerHealth").style.width = (tower.health / tower.maxHealth * 100) + "%";
}

function repairTower() {
  if (!selectedTower || money < 40) { showMessage("INSUFFICIENT CREDITS", "error"); return; }
  selectedTower.health = Math.min(selectedTower.maxHealth, selectedTower.health + 50);
  money -= 40;
  selectTowerOnCanvas(selectedTower);
}

function upgradeDamage() {
  if (!selectedTower || money < 50) { showMessage("INSUFFICIENT CREDITS", "error"); return; }
  selectedTower.damage += 4;
  money -= 50;
  selectTowerOnCanvas(selectedTower);
}

function upgradeRange() {
  if (!selectedTower || money < 60) { showMessage("INSUFFICIENT CREDITS", "error"); return; }
  selectedTower.range += 20;
  money -= 60;
  selectTowerOnCanvas(selectedTower);
}

function upgradeFireRate() {
  if (!selectedTower || money < 70) { showMessage("INSUFFICIENT CREDITS", "error"); return; }
  selectedTower.fireRate = Math.max(10, selectedTower.fireRate - 8);
  money -= 70;
  selectTowerOnCanvas(selectedTower);
}

function sellTower() {
  if (!selectedTower) return;
  const refund = selectedTower.baseCost * 0.6;
  money += Math.floor(refund);
  towers.splice(towers.indexOf(selectedTower), 1);
  selectedTower = null;
  document.getElementById("towerMgmtPanel").classList.remove("active");
}

canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  for (const tower of towers) {
    if (distance(x, y, tower.x, tower.y) < 25) {
      selectTowerOnCanvas(tower);
      return;
    }
  }
  
  if (selectedTowerType === -1) return;
  const cost = TOWER_TYPES[selectedTowerType].cost;
  if (money >= cost) {
    towers.push({
      x, y, type: selectedTowerType,
      color: TOWER_TYPES[selectedTowerType].color,
      range: TOWER_TYPES[selectedTowerType].range,
      damage: TOWER_TYPES[selectedTowerType].damage,
      fireRate: TOWER_TYPES[selectedTowerType].fireRate,
      size: TOWER_TYPES[selectedTowerType].size,
      cooldown: 0,
      baseCost: cost,
      health: 100,
      maxHealth: 100
    });
    money -= cost;
    selectedTowerType = -1;
    document.querySelectorAll(".tower-btn").forEach(btn => btn.classList.remove("active"));
  }
});

function update() {
  ctx.fillStyle = "#0a1a2e";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw grid
  ctx.strokeStyle = "rgba(0, 255, 255, 0.08)";
  const gridSize = 50;
  for (let x = 0; x < canvas.width; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }

  // Draw path
  if (currentPath.length > 0) {
    ctx.strokeStyle = "rgba(0, 255, 255, 0.3)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
  }

  if (!isPaused) {
    // Update and draw towers
    towers.forEach((t) => {
      ctx.fillStyle = t.color;
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.size, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = "white";
      ctx.font = `bold ${t.size}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(["‚ö°", "üí£", "„Ä∞"][t.type], t.x, t.y);

      if (t.cooldown > 0) {
        t.cooldown--;
      } else {
        let closest = null, closestDist = t.range;
        for (const e of enemies) {
          const dist = distance(t.x, t.y, e.x, e.y);
          if (dist < closestDist) { closest = e; closestDist = dist; }
        }
        if (closest) {
          closest.hp -= t.damage;
          t.cooldown = t.fireRate;
          ctx.strokeStyle = t.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(t.x, t.y);
          ctx.lineTo(closest.x, closest.y);
          ctx.stroke();
        }
      }
    });

    // Update and draw enemies
    enemies.forEach((e, i) => {
      if (e.pathIndex < currentPath.length - 1) {
        const current = currentPath[e.pathIndex];
        const next = currentPath[e.pathIndex + 1];
        const dx = next.x - current.x;
        const dy = next.y - current.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        e.progress += e.speed / dist;
        
        if (e.progress >= 1) {
          e.pathIndex++;
          e.progress = 0;
        } else {
          e.x = current.x + dx * e.progress;
          e.y = current.y + dy * e.progress;
        }
      }

      ctx.fillStyle = e.isBoss ? "#ff1744" : "#ff007f";
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.font = `bold ${e.radius}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(e.isBoss ? "üëë" : "üëæ", e.x, e.y);

      // Health bar
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(e.x - 20, e.y - 25, 40, 3);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(e.x - 20, e.y - 25, 40 * (e.hp / e.maxHp), 3);

      if (e.hp <= 0) {
        enemies.splice(i, 1);
        money += Math.floor(25 * e.rewardMult);
        totalKills++;
        return;
      }

      if (e.y > canvas.height) {
        enemies.splice(i, 1);
        enemiesEscaped++;
        money = Math.max(0, money - 50);
      }
    });
  }

  if (selectedTower) {
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(selectedTower.x, selectedTower.y, selectedTower.size + 8, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Update HUD
  document.getElementById("moneyDisplay").textContent = money;
  document.getElementById("levelDisplay").textContent = level;
  document.getElementById("towersDisplay").textContent = towers.length;
  document.getElementById("killsDisplay").textContent = totalKills;

  TOWER_TYPES.forEach((t, i) => {
    document.getElementById("towerBtn" + i).disabled = money < t.cost;
  });

  // Wave complete?
  if (waveActive && waveHasSpawned && enemies.length === 0) {
    if (enemiesEscaped <= 2) {
      waveActive = false;
      level++;
      bossWarningTriggered = false;
      document.getElementById("startBtn").disabled = false;
      showMessage("WAVE CLEAR", "success");
    } else {
      waveActive = false;
      enemiesEscaped = 0;
      showMessage("TOO MANY ESCAPES", "error");
    }
  }

  requestAnimationFrame(update);
}

// Initialize
initCanvas();
generatePath();
update();

// Handle window resize
window.addEventListener('resize', () => {
  initCanvas();
  generatePath();
});
</script>

</body>
</html>
