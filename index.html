<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Strategic Tower Defense</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body {
  margin: 0;
  background: #0b1220;
  color: #fff;
  font-family: system-ui, sans-serif;
}

#topbar {
  display: flex;
  justify-content: space-between;
  padding: 10px;
  background: #111a30;
}

button {
  background: #2563eb;
  border: none;
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 14px;
}

#shop {
  display: flex;
  gap: 6px;
}

canvas {
  display: block;
  margin: auto;
  background: #1a2440;
  touch-action: none;
}

#panel {
  background: #0f172a;
  padding: 10px;
  display: none;
}
</style>
</head>

<body>

<div id="topbar">
  <div>‚ù§Ô∏è <span id="lives">20</span></div>
  <div>üí∞ <span id="gold">150</span></div>
  <div>Level <span id="level">1</span></div>
</div>

<div id="shop">
  <button onclick="selectTower('basic')">Basic (50)</button>
  <button onclick="selectTower('sniper')">Sniper (75)</button>
  <button onclick="selectTower('splash')">Splash (100)</button>
</div>

<canvas id="game" width="360" height="540"></canvas>

<div id="panel"></div>

<script>
/* ==========================
   CORE CONSTANTS
========================== */
const TILE = 60;
const COLS = 6;
const ROWS = 9;

/* ==========================
   GAME STATE
========================== */
let lives = 20;
let gold = 150;
let level = 1;

let placingType = null;
let selectedTower = null;

const towers = [];
const enemies = [];

/* ==========================
   CANVAS
========================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* ==========================
   AUTO SPRITES
========================== */
function sprite(color, label) {
  const c = document.createElement("canvas");
  c.width = c.height = TILE;
  const g = c.getContext("2d");
  g.fillStyle = color;
  g.fillRect(6,6,TILE-12,TILE-12);
  g.strokeStyle = "#fff";
  g.strokeRect(6,6,TILE-12,TILE-12);
  g.fillStyle = "#fff";
  g.font = "12px sans-serif";
  g.fillText(label, 10, 32);
  return c;
}

const sprites = {
  basic: sprite("#3b82f6","B"),
  sniper: sprite("#22c55e","S"),
  splash: sprite("#eab308","A"),
  enemy: sprite("#ef4444",""),
  fast: sprite("#f97316",""),
  tank: sprite("#9333ea",""),
  boss: sprite("#000","")
};

/* ==========================
   PATH
========================== */
const path = [
  {x:0,y:4},{x:1,y:4},{x:2,y:4},
  {x:3,y:4},{x:4,y:4},{x:5,y:4}
];

/* ==========================
   TOWER DEFINITIONS
========================== */
const towerStats = {
  basic: { cost:50, dmg:6, range:120, rate:30 },
  sniper:{ cost:75, dmg:18, range:220, rate:90 },
  splash:{ cost:100,dmg:8, range:100, rate:60, splash:50 }
};

/* ==========================
   INPUT
========================== */
function selectTower(type) {
  if (gold >= towerStats[type].cost) placingType = type;
}

canvas.addEventListener("touchstart", e => {
  const rect = canvas.getBoundingClientRect();
  const t = e.touches[0];
  const x = Math.floor((t.clientX - rect.left)/TILE);
  const y = Math.floor((t.clientY - rect.top)/TILE);

  const clicked = towers.find(t => t.x===x && t.y===y);
  if (clicked) {
    openPanel(clicked);
    return;
  }

  if (!placingType) return;
  if (path.some(p=>p.x===x&&p.y===y)) return;

  towers.push({
    type: placingType,
    x,y,
    level:1,
    cooldown:0
  });

  gold -= towerStats[placingType].cost;
  placingType = null;
  updateUI();
});

/* ==========================
   WAVES & ENEMIES
========================== */
function spawnWave() {
  const count = 5 + level * 2;
  for (let i=0;i<count;i++) {
    setTimeout(()=>spawnEnemy(), i*500);
  }
  if (level % 10 === 0) spawnEnemy("boss");
}

function spawnEnemy(type="normal") {
  const base = {
    x: path[0].x*TILE,
    y: path[0].y*TILE,
    step:0
  };

  if (type==="fast") enemies.push({...base,hp:15+level,spd:2,type:"fast"});
  else if (type==="tank") enemies.push({...base,hp:60+level*5,spd:0.6,type:"tank"});
  else if (type==="boss") enemies.push({...base,hp:300+level*20,spd:0.4,type:"boss"});
  else enemies.push({...base,hp:25+level*2,spd:1,type:"normal"});
}

/* ==========================
   GAME LOOP
========================== */
function update() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // path
  path.forEach(p=>{
    ctx.fillStyle="#374151";
    ctx.fillRect(p.x*TILE,p.y*TILE,TILE,TILE);
  });

  // towers
  towers.forEach(t=>{
    ctx.drawImage(sprites[t.type],t.x*TILE,t.y*TILE);
    t.cooldown--;
  });

  // enemies
  for (let i=enemies.length-1;i>=0;i--) {
    const e = enemies[i];
    const next = path[e.step+1];
    if (next) {
      const tx=next.x*TILE, ty=next.y*TILE;
      const dx=tx-e.x, dy=ty-e.y;
      const d=Math.hypot(dx,dy);
      e.x+=dx/d*e.spd;
      e.y+=dy/d*e.spd;
      if (d<2) e.step++;
    } else {
      lives--;
      enemies.splice(i,1);
      updateUI();
      continue;
    }

    ctx.drawImage(sprites[e.type]||sprites.enemy,e.x,e.y);
  }

  // combat
  towers.forEach(t=>{
    if (t.cooldown>0) return;
    enemies.forEach((e,i)=>{
      const dx=e.x-t.x*TILE;
      const dy=e.y-t.y*TILE;
      if (Math.hypot(dx,dy)<towerStats[t.type].range) {
        e.hp-=towerStats[t.type].dmg*t.level;
        t.cooldown=towerStats[t.type].rate;
        if (e.hp<=0) {
          enemies.splice(i,1);
          gold+=10;
          updateUI();
        }
      }
    });
  });

  requestAnimationFrame(update);
}

/* ==========================
   UI
========================== */
function updateUI() {
  livesEl.textContent=lives;
  goldEl.textContent=gold;
  levelEl.textContent=level;
}

const livesEl=document.getElementById("lives");
const goldEl=document.getElementById("gold");
const levelEl=document.getElementById("level");

/* ==========================
   START
========================== */
setInterval(()=>{
  spawnWave();
  level++;
  updateUI();
},12000);

updateUI();
update();
</script>

</body>
</html>
