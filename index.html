<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<title>Nexus Defense</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

body {
background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0f0f25 100%);
color: #e0e7ff;
font-family: ‚ÄòCourier New‚Äô, monospace;
min-height: 100vh;
display: flex;
flex-direction: column;
align-items: center;
padding: 20px;
overflow-x: hidden;
}

h1 {
font-size: 2.5em;
margin-bottom: 5px;
text-shadow: 0 0 20px rgba(139, 92, 246, 0.8);
color: #c4b5fd;
letter-spacing: 3px;
}

.subtitle {
color: #a78bfa;
font-size: 0.9em;
margin-bottom: 20px;
opacity: 0.7;
}

.container {
display: flex;
gap: 20px;
align-items: flex-start;
justify-content: center;
flex-wrap: wrap;
max-width: 1400px;
}

.game-area {
display: flex;
flex-direction: column;
gap: 15px;
}

canvas {
background: linear-gradient(45deg, #1a1f3a 0%, #252d4a 50%, #1f2640 100%);
border: 2px solid #7c3aed;
border-radius: 8px;
display: block;
box-shadow:
0 0 30px rgba(124, 58, 237, 0.4),
inset 0 0 30px rgba(124, 58, 237, 0.1);
cursor: crosshair;
position: relative;
}

.canvas-overlay {
position: relative;
}

.pause-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.7);
border-radius: 8px;
display: none;
align-items: center;
justify-content: center;
font-size: 2em;
font-weight: bold;
color: #c4b5fd;
text-shadow: 0 0 20px rgba(139, 92, 246, 0.8);
z-index: 999;
}

.pause-overlay.active {
display: flex;
}

.controls {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
gap: 10px;
}

button {
padding: 12px 16px;
font-size: 14px;
font-family: ‚ÄòCourier New‚Äô, monospace;
background: linear-gradient(135deg, #7c3aed, #6d28d9);
border: 2px solid #a78bfa;
color: #e0e7ff;
border-radius: 6px;
cursor: pointer;
font-weight: bold;
transition: all 0.3s ease;
position: relative;
overflow: hidden;
}

button:hover {
background: linear-gradient(135deg, #a78bfa, #8b5cf6);
box-shadow: 0 0 20px rgba(167, 139, 250, 0.6);
transform: translateY(-2px);
}

button:active {
transform: translateY(0);
}

button.active {
background: linear-gradient(135deg, #10b981, #059669);
border-color: #34d399;
box-shadow: 0 0 20px rgba(52, 211, 153, 0.6);
}

button:disabled {
opacity: 0.5;
cursor: not-allowed;
}

.sidebar {
background: rgba(15, 23, 42, 0.8);
border: 2px solid #7c3aed;
border-radius: 8px;
padding: 20px;
min-width: 280px;
box-shadow: 0 0 20px rgba(124, 58, 237, 0.3);
max-height: 800px;
overflow-y: auto;
}

.stat-group {
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid rgba(124, 58, 237, 0.3);
}

.stat-group:last-child {
border-bottom: none;
}

.stat-label {
color: #a78bfa;
font-size: 0.85em;
text-transform: uppercase;
letter-spacing: 1px;
margin-bottom: 5px;
}

.stat-value {
font-size: 1.8em;
color: #c4b5fd;
font-weight: bold;
text-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
}

.tower-info {
background: rgba(124, 58, 237, 0.1);
border: 1px solid rgba(124, 58, 237, 0.5);
border-radius: 6px;
padding: 12px;
margin-bottom: 10px;
font-size: 0.85em;
cursor: pointer;
transition: all 0.3s ease;
}

.tower-info:hover {
background: rgba(124, 58, 237, 0.2);
border-color: rgba(124, 58, 237, 0.8);
transform: translateX(5px);
}

.tower-info.selected {
background: rgba(16, 185, 129, 0.2);
border-color: #10b981;
}

.tower-name {
color: #c4b5fd;
font-weight: bold;
margin-bottom: 4px;
}

.tower-stat {
color: #a78bfa;
font-size: 0.8em;
margin: 2px 0;
}

.selected-tower {
background: rgba(59, 130, 246, 0.15);
border: 1px solid rgba(59, 130, 246, 0.6);
border-radius: 6px;
padding: 12px;
margin-bottom: 15px;
}

.upgrade-btn {
width: 100%;
padding: 8px 12px;
margin: 5px 0;
font-size: 12px;
background: linear-gradient(135deg, #3b82f6, #2563eb);
border: 1px solid #60a5fa;
color: #e0e7ff;
border-radius: 4px;
cursor: pointer;
transition: all 0.3s ease;
}

.upgrade-btn:hover:not(:disabled) {
background: linear-gradient(135deg, #60a5fa, #3b82f6);
box-shadow: 0 0 15px rgba(59, 130, 246, 0.6);
}

.upgrade-btn:disabled {
opacity: 0.4;
cursor: not-allowed;
}

.message {
position: fixed;
top: 20px;
left: 50%;
transform: translateX(-50%);
background: rgba(16, 185, 129, 0.9);
color: white;
padding: 12px 20px;
border-radius: 6px;
font-weight: bold;
opacity: 0;
animation: slideIn 0.3s ease forwards, slideOut 0.3s ease 2.7s forwards;
pointer-events: none;
z-index: 1000;
}

@keyframes slideIn {
from {
opacity: 0;
transform: translateX(-50%) translateY(-20px);
}
to {
opacity: 1;
transform: translateX(-50%) translateY(0);
}
}

@keyframes slideOut {
to {
opacity: 0;
transform: translateX(-50%) translateY(-20px);
}
}

.wave-indicator {
position: absolute;
top: 10px;
left: 10px;
background: rgba(124, 58, 237, 0.8);
padding: 8px 12px;
border-radius: 4px;
font-size: 0.9em;
font-weight: bold;
text-shadow: 0 0 10px rgba(139, 92, 246, 0.8);
z-index: 10;
}

.pause-status {
position: absolute;
top: 10px;
right: 10px;
background: rgba(239, 68, 68, 0.8);
color: white;
padding: 8px 12px;
border-radius: 4px;
font-size: 0.9em;
font-weight: bold;
display: none;
z-index: 10;
}

.pause-status.active {
display: block;
}

.difficulty-badge {
position: absolute;
top: 50px;
left: 10px;
background: rgba(249, 115, 22, 0.8);
padding: 6px 10px;
border-radius: 4px;
font-size: 0.8em;
font-weight: bold;
z-index: 10;
}

.save-indicator {
position: absolute;
bottom: 10px;
right: 10px;
background: rgba(16, 185, 129, 0.6);
color: white;
padding: 6px 10px;
border-radius: 4px;
font-size: 0.8em;
font-weight: bold;
z-index: 10;
opacity: 0;
transition: opacity 0.3s ease;
}

.save-indicator.active {
opacity: 1;
}
</style>

</head>

<body>
<h1>‚ö° NEXUS DEFENSE ‚ö°</h1>
<p class="subtitle">Strategic tower placement ‚Ä¢ Wave-based combat ‚Ä¢ Auto-saving progress</p>

<div class="container">
  <div class="game-area">
    <div class="canvas-overlay">
      <canvas id="game" width="900" height="500"></canvas>
      <div class="pause-overlay" id="pauseOverlay">‚è∏ PAUSED</div>
      <div class="wave-indicator" id="waveIndicator">Wave: 1</div>
      <div class="pause-status" id="pauseStatus">PAUSED</div>
      <div class="difficulty-badge" id="difficultyBadge">Normal</div>
      <div class="save-indicator" id="saveIndicator">üíæ Saved</div>
    </div>

```
<div class="controls">
  <button id="towerBtn0" onclick="selectTower(0)">üîµ Laser ($150)</button>
  <button id="towerBtn1" onclick="selectTower(1)">üî∂ Cannon ($200)</button>
  <button id="towerBtn2" onclick="selectTower(2)">üü¢ Pulse ($180)</button>
  <button id="pauseBtn" onclick="togglePause()">‚è∏ PAUSE</button>
  <button id="startBtn" onclick="startWave()">‚ñ∂ WAVE</button>
  <button onclick="resetGame()" style="background: linear-gradient(135deg, #dc2626, #991b1b); border-color: #fca5a5;">üîÑ RESET</button>
</div>
```

  </div>

  <div class="sidebar">
    <div class="stat-group" style="background: rgba(59, 130, 246, 0.2); border: 1px solid rgba(59, 130, 246, 0.6); padding: 10px; border-radius: 4px; margin-bottom: 15px;">
      <div style="font-size: 0.85em; color: #60a5fa; margin-bottom: 5px;">üí° Click towers to upgrade ‚Ä¢ Game auto-saves!</div>
    </div>

```
<div class="stat-group">
  <div class="stat-label">üí∞ Balance</div>
  <div class="stat-value" id="moneyDisplay">$500</div>
</div>

<div class="stat-group">
  <div class="stat-label">üìä Stats</div>
  <div class="stat-label" style="margin-top: 10px;">Wave</div>
  <div class="stat-value" id="levelDisplay" style="font-size: 1.4em;">1</div>
  <div class="stat-label" style="margin-top: 10px;">Towers Built</div>
  <div class="stat-value" id="towersDisplay" style="font-size: 1.4em;">0</div>
  <div class="stat-label" style="margin-top: 10px;">Enemies Defeated</div>
  <div class="stat-value" id="killsDisplay" style="font-size: 1.4em;">0</div>
</div>

<div class="stat-group" id="selectedTowerPanel" style="display: none;">
  <div class="stat-label">üéØ Selected Tower</div>
  <div class="selected-tower">
    <div class="tower-name" id="selectedTowerName">-</div>
    <div class="tower-stat" id="selectedTowerStats"></div>
    <button class="upgrade-btn" onclick="upgradeDamage()" id="upgradeDmgBtn">üí™ Upgrade Damage ($50)</button>
    <button class="upgrade-btn" onclick="upgradeRange()" id="upgradeRngBtn">üìè Upgrade Range ($60)</button>
    <button class="upgrade-btn" onclick="upgradeFireRate()" id="upgradeFireBtn">‚ö° Upgrade Speed ($70)</button>
    <button class="upgrade-btn" onclick="sellTower()" style="background: linear-gradient(135deg, #ef4444, #dc2626); border-color: #fca5a5;">üí∏ Sell Tower</button>
    <button class="upgrade-btn" onclick="closeTowerPanel()" style="background: linear-gradient(135deg, #6b7280, #4b5563); border-color: #9ca3af; margin-top: 10px;">‚óÄ Back</button>
  </div>
</div>

<div class="stat-group">
  <div class="stat-label">üéØ Tower Types</div>
  <div class="tower-info" id="info0">
    <div class="tower-name">Laser</div>
    <div class="tower-stat">DMG: 12 | Range: 120</div>
    <div class="tower-stat">Speed: Fast</div>
  </div>
  <div class="tower-info" id="info1">
    <div class="tower-name">Cannon</div>
    <div class="tower-stat">DMG: 20 | Range: 150</div>
    <div class="tower-stat">Speed: Slow</div>
  </div>
  <div class="tower-info" id="info2">
    <div class="tower-name">Pulse</div>
    <div class="tower-stat">DMG: 8 | Range: 160</div>
    <div class="tower-stat">Speed: Medium</div>
  </div>
</div>
```

  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// Game state
let money = 500;
let level = 1;
let waveActive = false;
let placingTower = false;
let selectedTowerType = -1;
let selectedTower = null;
let isPaused = false;
let totalKills = 0;
let enemiesEscaped = 0;
let gameRunning = true;

const towers = [];
const enemies = [];
const particles = [];

// Tower definitions
const TOWER_TYPES = [
  { name: "Laser", cost: 150, color: "#00bfff", damage: 12, range: 120, fireRate: 40, size: 14 },
  { name: "Cannon", cost: 200, color: "#ff8c00", damage: 20, range: 150, fireRate: 60, size: 16 },
  { name: "Pulse", cost: 180, color: "#00ff88", damage: 8, range: 160, fireRate: 25, size: 15 }
];

// Multiple paths for different waves
const PATHS = [
  // Waves 1-2
  [
    { x: 450, y: -20 },
    { x: 450, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 280 },
    { x: 700, y: 280 },
    { x: 700, y: 420 },
    { x: 100, y: 420 },
    { x: 100, y: 550 }
  ],
  // Waves 3-4
  [
    { x: 800, y: -20 },
    { x: 800, y: 150 },
    { x: 400, y: 150 },
    { x: 400, y: 100 },
    { x: 100, y: 100 },
    { x: 100, y: 350 },
    { x: 800, y: 350 },
    { x: 800, y: 550 }
  ],
  // Waves 5+
  [
    { x: 100, y: -20 },
    { x: 100, y: 150 },
    { x: 500, y: 150 },
    { x: 500, y: 80 },
    { x: 800, y: 80 },
    { x: 800, y: 300 },
    { x: 300, y: 300 },
    { x: 300, y: 450 },
    { x: 650, y: 450 },
    { x: 650, y: 550 }
  ]
];

let currentPath = PATHS[0];
let lastPathIndex = 0;

// Enemy types with different speeds
const ENEMY_TYPES = [
  { name: "Scout", speedMult: 1.1, hpMult: 0.8, rewardMult: 0.8 },
  { name: "Trooper", speedMult: 1.0, hpMult: 1.0, rewardMult: 1.0 },
  { name: "Tank", speedMult: 0.6, hpMult: 1.5, rewardMult: 1.3 }
];

// ========================
// SAVE/LOAD SYSTEM
// ========================
function saveGame() {
  const gameData = {
    money,
    level,
    totalKills,
    enemiesEscaped,
    towers: towers.map(t => ({
      x: t.x, y: t.y, type: t.type,
      damageUpgrades: t.damageUpgrades,
      rangeUpgrades: t.rangeUpgrades,
      speedUpgrades: t.speedUpgrades,
      baseCost: t.baseCost
    }))
  };
  localStorage.setItem('nexusDefense', JSON.stringify(gameData));
  
  // Show save indicator
  const saveInd = document.getElementById("saveIndicator");
  saveInd.classList.add("active");
  setTimeout(() => saveInd.classList.remove("active"), 2000);
}

function loadGame() {
  const saved = localStorage.getItem('nexusDefense');
  if (!saved) return false;
  
  try {
    const gameData = JSON.parse(saved);
    money = gameData.money;
    level = gameData.level;
    totalKills = gameData.totalKills;
    enemiesEscaped = gameData.enemiesEscaped;
    
    // Recreate towers
    towers.length = 0;
    gameData.towers.forEach(tData => {
      towers.push({
        x: tData.x, y: tData.y, type: tData.type,
        color: TOWER_TYPES[tData.type].color,
        range: TOWER_TYPES[tData.type].range + (tData.rangeUpgrades * 20),
        damage: TOWER_TYPES[tData.type].damage + (tData.damageUpgrades * 4),
        fireRate: Math.max(10, TOWER_TYPES[tData.type].fireRate - (tData.speedUpgrades * 8)),
        size: TOWER_TYPES[tData.type].size,
        cooldown: 0,
        target: null,
        damageUpgrades: tData.damageUpgrades,
        rangeUpgrades: tData.rangeUpgrades,
        speedUpgrades: tData.speedUpgrades,
        baseCost: tData.baseCost
      });
    });
    
    // Update path based on loaded level
    updatePath();
    
    showMessage("üìÇ Game loaded!", "#3b82f6");
    return true;
  } catch (e) {
    console.error("Load failed:", e);
    return false;
  }
}

function updatePath() {
  const newPathIndex = level <= 2 ? 0 : level <= 4 ? 1 : 2;
  if (newPathIndex !== lastPathIndex) {
    // Path changed, reset towers and refund
    if (towers.length > 0) {
      let refundTotal = 0;
      towers.forEach(t => {
        refundTotal += t.baseCost * 0.6;
      });
      money += Math.floor(refundTotal);
      towers.length = 0;
      selectedTower = null;
      document.getElementById("selectedTowerPanel").style.display = "none";
      showMessage(`üîÑ Path changed! Towers reset. +$${Math.floor(refundTotal)} refund`, "#fbbf24");
    }
    lastPathIndex = newPathIndex;
  }
  currentPath = PATHS[newPathIndex];
}

// ========================
// UTILITY FUNCTIONS
// ========================
function distance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

function showMessage(text, color = "#10b981") {
  const msg = document.createElement("div");
  msg.className = "message";
  msg.textContent = text;
  msg.style.background = color;
  document.body.appendChild(msg);
  setTimeout(() => msg.remove(), 3000);
}

function togglePause() {
  if (!waveActive) {
    showMessage("Start a wave first!", "#ef4444");
    return;
  }
  isPaused = !isPaused;
  document.getElementById("pauseOverlay").classList.toggle("active");
  document.getElementById("pauseStatus").classList.toggle("active");
  document.getElementById("pauseBtn").textContent = isPaused ? "‚ñ∂ RESUME" : "‚è∏ PAUSE";
}

// ========================
// TOWER MANAGEMENT
// ========================
function createTower(x, y, type) {
  const t = TOWER_TYPES[type];
  towers.push({
    x, y, type,
    color: t.color,
    range: t.range,
    damage: t.damage,
    fireRate: t.fireRate,
    size: t.size,
    cooldown: 0,
    target: null,
    damageUpgrades: 0,
    rangeUpgrades: 0,
    speedUpgrades: 0,
    baseCost: t.cost
  });
  saveGame();
}

function selectTower(type) {
  if (money < TOWER_TYPES[type].cost) {
    showMessage("üí∏ Insufficient funds!", "#ef4444");
    return;
  }
  selectedTowerType = type;
  placingTower = true;
  selectedTower = null;
  document.getElementById("selectedTowerPanel").style.display = "none";
  
  document.querySelectorAll("button").forEach(btn => btn.classList.remove("active"));
  document.getElementById(`towerBtn${type}`).classList.add("active");
  document.getElementById(`info${type}`).classList.add("selected");
}

function selectTowerOnCanvas(tower) {
  selectedTower = tower;
  document.getElementById("selectedTowerPanel").style.display = "block";
  document.getElementById("selectedTowerName").textContent = TOWER_TYPES[tower.type].name + ` (Lv.${tower.damageUpgrades + tower.rangeUpgrades + tower.speedUpgrades})`;
  document.getElementById("selectedTowerStats").innerHTML = `
    DMG: ${tower.damage} | Range: ${tower.range} | Speed: ${tower.fireRate}
  `;
}

function closeTowerPanel() {
  selectedTower = null;
  document.getElementById("selectedTowerPanel").style.display = "none";
}

function upgradeDamage() {
  if (!selectedTower || money < 50) {
    showMessage("üí∏ Insufficient funds ($50)!", "#ef4444");
    return;
  }
  selectedTower.damage += 4;
  selectedTower.damageUpgrades++;
  money -= 50;
  selectTowerOnCanvas(selectedTower);
  saveGame();
  showMessage("üí™ Tower upgraded!", "#10b981");
}

function upgradeRange() {
  if (!selectedTower || money < 60) {
    showMessage("üí∏ Insufficient funds ($60)!", "#ef4444");
    return;
  }
  selectedTower.range += 20;
  selectedTower.rangeUpgrades++;
  money -= 60;
  selectTowerOnCanvas(selectedTower);
  saveGame();
  showMessage("üìè Range increased!", "#10b981");
}

function upgradeFireRate() {
  if (!selectedTower || money < 70) {
    showMessage("üí∏ Insufficient funds ($70)!", "#ef4444");
    return;
  }
  selectedTower.fireRate = Math.max(10, selectedTower.fireRate - 8);
  selectedTower.speedUpgrades++;
  money -= 70;
  selectTowerOnCanvas(selectedTower);
  saveGame();
  showMessage("‚ö° Fire rate increased!", "#10b981");
}

function sellTower() {
  if (!selectedTower) return;
  const refund = selectedTower.baseCost * 0.6;
  money += Math.floor(refund);
  towers.splice(towers.indexOf(selectedTower), 1);
  selectedTower = null;
  document.getElementById("selectedTowerPanel").style.display = "none";
  saveGame();
  showMessage(`üí∞ Sold tower for $${Math.floor(refund)}`, "#fbbf24");
}

// ========================
// ENEMY MANAGEMENT
// ========================
function spawnEnemy() {
  const typeIndex = Math.floor(Math.random() * Math.min(3, Math.floor(level / 2) + 1));
  const type = ENEMY_TYPES[typeIndex];
  const baseHp = 30 + level * 15;
  
  const hp = baseHp * type.hpMult;
  enemies.push({
    x: currentPath[0].x,
    y: currentPath[0].y,
    hp: hp,
    maxHp: hp,
    speed: (1.5 + level * 0.1) * type.speedMult,
    radius: 10,
    pathIndex: 0,
    progress: 0,
    type: typeIndex,
    typeName: type.name,
    rewardMult: type.rewardMult
  });
}

// ========================
// PARTICLE EFFECTS
// ========================
function createParticles(x, y, color, count = 8) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count;
    particles.push({
      x, y,
      vx: Math.cos(angle) * 3,
      vy: Math.sin(angle) * 3,
      life: 20,
      color: color,
      size: 3
    });
  }
}

// ========================
// INPUT HANDLING
// ========================
canvas.addEventListener("click", (e) => {
  if (!placingTower || selectedTowerType === -1) {
    // Try to select a tower
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    for (const tower of towers) {
      if (distance(x, y, tower.x, tower.y) < 25) {
        selectTowerOnCanvas(tower);
        return;
      }
    }
    return;
  }
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const cost = TOWER_TYPES[selectedTowerType].cost;
  if (money >= cost) {
    createTower(x, y, selectedTowerType);
    money -= cost;
    createParticles(x, y, TOWER_TYPES[selectedTowerType].color, 12);
    placingTower = false;
    selectedTowerType = -1;
    document.querySelectorAll("button").forEach(btn => btn.classList.remove("active"));
    document.querySelectorAll(".tower-info").forEach(el => el.classList.remove("selected"));
  } else {
    showMessage("üí∏ Insufficient funds!", "#ef4444");
  }
});

// ========================
// GAME CONTROLS
// ========================
function startWave() {
  if (waveActive) return;
  waveActive = true;
  enemiesEscaped = 0;
  document.getElementById("startBtn").disabled = true;
  
  let count = 0;
  const enemyCount = 5 + level * 2;
  const spawnInterval = setInterval(() => {
    if (!isPaused) {
      spawnEnemy();
      count++;
    }
    if (count >= enemyCount) {
      clearInterval(spawnInterval);
    }
  }, 600);
}

function resetGame() {
  if (confirm("Reset all progress?")) {
    money = 500;
    level = 1;
    totalKills = 0;
    enemiesEscaped = 0;
    towers.length = 0;
    enemies.length = 0;
    waveActive = false;
    placingTower = false;
    selectedTowerType = -1;
    selectedTower = null;
    isPaused = false;
    lastPathIndex = 0;
    document.getElementById("startBtn").disabled = false;
    document.getElementById("pauseBtn").textContent = "‚è∏ PAUSE";
    document.getElementById("pauseOverlay").classList.remove("active");
    document.getElementById("pauseStatus").classList.remove("active");
    document.querySelectorAll("button").forEach(btn => btn.classList.remove("active"));
    document.querySelectorAll(".tower-info").forEach(el => el.classList.remove("selected"));
    document.getElementById("selectedTowerPanel").style.display = "none";
    currentPath = PATHS[0];
    localStorage.removeItem('nexusDefense');
    showMessage("üîÑ Game reset!", "#3b82f6");
  }
}

// ========================
// MAIN GAME LOOP
// ========================
function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw grid background
  ctx.strokeStyle = "rgba(124, 58, 237, 0.1)";
  ctx.lineWidth = 1;
  for (let x = 0; x < canvas.width; x += 50) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += 50) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  // Draw enemy path
  ctx.strokeStyle = "rgba(59, 130, 246, 0.4)";
  ctx.lineWidth = 4;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.beginPath();
  ctx.moveTo(currentPath[0].x, currentPath[0].y);
  for (let i = 1; i < currentPath.length; i++) {
    ctx.lineTo(currentPath[i].x, currentPath[i].y);
  }
  ctx.stroke();

  // Draw path nodes
  ctx.fillStyle = "rgba(59, 130, 246, 0.6)";
  currentPath.forEach(point => {
    ctx.beginPath();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.fill();
  });

  if (!isPaused) {
    // Update and draw towers
    towers.forEach((t) => {
      // Draw tower
      ctx.fillStyle = t.color;
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw glow
      ctx.strokeStyle = t.color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Shooting logic
      if (t.cooldown > 0) {
        t.cooldown--;
      } else {
        let closest = null;
        let closestDist = t.range;

        for (const e of enemies) {
          const dist = distance(t.x, t.y, e.x, e.y);
          if (dist < closestDist) {
            closest = e;
            closestDist = dist;
          }
        }

        if (closest) {
          closest.hp -= t.damage;
          t.cooldown = t.fireRate;
          createParticles(closest.x, closest.y, t.color, 5);

          // Draw projectile
          ctx.strokeStyle = t.color;
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.moveTo(t.x, t.y);
          ctx.lineTo(closest.x, closest.y);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
    });

    // Update and draw enemies
    enemies.forEach((e, i) => {
      // Follow path
      if (e.pathIndex < currentPath.length - 1) {
        const current = currentPath[e.pathIndex];
        const next = currentPath[e.pathIndex + 1];
        
        const dx = next.x - current.x;
        const dy = next.y - current.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        e.progress += e.speed / dist;
        
        if (e.progress >= 1) {
          e.pathIndex++;
          e.progress = 0;
        } else {
          e.x = current.x + dx * e.progress;
          e.y = current.y + dy * e.progress;
        }
      } else {
        e.y = currentPath[currentPath.length - 1].y;
      }

      // Draw enemy
      ctx.fillStyle = e.type === 0 ? "#fbbf24" : e.type === 1 ? "#ef4444" : "#8b5cf6";
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
      ctx.fill();

      // Draw glow
      ctx.strokeStyle = e.type === 0 ? "#f59e0b" : e.type === 1 ? "#ff6b6b" : "#a78bfa";
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius + 3, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // HP bar
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(e.x - 20, e.y - 25, 40, 5);
      const hpPercent = e.hp / e.maxHp;
      ctx.fillStyle = hpPercent > 0.5 ? "#22c55e" : hpPercent > 0.2 ? "#f59e0b" : "#ef4444";
      ctx.fillRect(e.x - 20, e.y - 25, 40 * hpPercent, 5);

      // Remove if dead
      if (e.hp <= 0) {
        enemies.splice(i, 1);
        money += Math.floor(25 * e.rewardMult);
        totalKills++;
        createParticles(e.x, e.y, "#fbbf24", 15);
        return;
      }

      // Remove if escaped
      if (e.y > canvas.height) {
        enemies.splice(i, 1);
        enemiesEscaped++;
        money = Math.max(0, money - 50);
        createParticles(e.x, e.y, "#ef4444", 10);
      }
    });
  }

  // Draw selected tower highlight
  if (selectedTower) {
    ctx.strokeStyle = "#3b82f6";
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.arc(selectedTower.x, selectedTower.y, selectedTower.size + 8, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Update and draw particles
  particles.forEach((p, i) => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.life--;

    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life / 20;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();

    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  });
  ctx.globalAlpha = 1;

  // Wave complete logic - only restart if 3+ enemies escaped
  if (waveActive && enemies.length === 0) {
    if (enemiesEscaped <= 2) {
      waveActive = false;
      level++;
      updatePath();
      document.getElementById("startBtn").disabled = false;
      document.getElementById("pauseBtn").textContent = "‚è∏ PAUSE";
      isPaused = false;
      document.getElementById("pauseOverlay").classList.remove("active");
      document.getElementById("pauseStatus").classList.remove("active");
      saveGame();
      const escapeMsg = enemiesEscaped > 0 ? ` (${enemiesEscaped} escaped)` : "";
      showMessage(`‚ú® Wave Complete! Level ${level}${escapeMsg}`, "#10b981");
    } else if (enemiesEscaped > 2) {
      // 3+ enemies escaped - restart wave
      waveActive = false;
      enemiesEscaped = 0;
      document.getElementById("startBtn").disabled = false;
      document.getElementById("pauseBtn").textContent = "‚è∏ PAUSE";
      isPaused = false;
      document.getElementById("pauseOverlay").classList.remove("active");
      document.getElementById("pauseStatus").classList.remove("active");
      showMessage("‚ùå 3+ enemies escaped! Retrying wave...", "#ef4444");
    }
  }

  // Update UI
  document.getElementById("moneyDisplay").textContent = `$${money}`;
  document.getElementById("levelDisplay").textContent = level;
  document.getElementById("towersDisplay").textContent = towers.length;
  document.getElementById("killsDisplay").textContent = totalKills;
  document.getElementById("waveIndicator").textContent = `Wave: ${level} | Enemies: ${enemies.length}${enemiesEscaped > 0 ? ` | Escaped: ${enemiesEscaped}` : ''}`;
  
  let difficulty = "Normal";
  if (level <= 3) difficulty = "Easy";
  else if (level <= 7) difficulty = "Normal";
  else if (level <= 12) difficulty = "Hard";
  else difficulty = "Insane";
  document.getElementById("difficultyBadge").textContent = difficulty;

  // Disable tower buttons if can't afford
  TOWER_TYPES.forEach((t, i) => {
    document.getElementById(`towerBtn${i}`).disabled = money < t.cost;
  });

  requestAnimationFrame(update);
}

// Load game on start
if (!loadGame()) {
  updatePath();
}

update();
</script>

</body>
</html>
