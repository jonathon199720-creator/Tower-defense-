<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Tower Defense</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body {
  margin: 0;
  background: #0b1220;
  color: #fff;
  font-family: system-ui, sans-serif;
  text-align: center;
}

h1 {
  margin: 10px 0;
}

#ui {
  display: flex;
  justify-content: space-around;
  padding: 10px;
  background: #111a30;
  position: sticky;
  top: 0;
  z-index: 10;
}

button {
  padding: 10px 14px;
  font-size: 16px;
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 8px;
}

button:disabled {
  background: #444;
}

#game {
  display: block;
  margin: 0 auto;
  background: #1a2440;
  touch-action: none;
}
</style>
</head>

<body>

<h1>Pixel Tower Defense</h1>

<div id="ui">
  <div>‚ù§Ô∏è <span id="lives">20</span></div>
  <div>üí∞ <span id="gold">100</span></div>
  <div>Level <span id="level">1</span></div>
  <button id="towerBtn">Add Tower (50)</button>
</div>

<canvas id="game" width="360" height="540"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const towerImg = new Image();
towerImg.src = "assets/tower.png";

const enemyImg = new Image();
enemyImg.src = "assets/enemy.png";

const pathImg = new Image();
pathImg.src = "assets/path.png";

let lives = 20;
let gold = 100;
let level = 1;

const gridSize = 60;
const cols = 6;
const rows = 9;

let towers = [];
let enemies = [];
let placingTower = false;

const path = [
  {x:0,y:4},{x:1,y:4},{x:2,y:4},
  {x:3,y:4},{x:4,y:4},{x:5,y:4}
];

document.getElementById("towerBtn").onclick = () => {
  if (gold >= 50) placingTower = true;
};

canvas.addEventListener("touchstart", placeTower);

function placeTower(e) {
  if (!placingTower) return;

  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];

  const x = Math.floor((touch.clientX - rect.left) / gridSize);
  const y = Math.floor((touch.clientY - rect.top) / gridSize);

  if (path.some(p => p.x === x && p.y === y)) return;
  if (towers.some(t => t.x === x && t.y === y)) return;

  towers.push({x, y, cooldown: 0});
  gold -= 50;
  placingTower = false;
  updateUI();
}

function spawnEnemy() {
  enemies.push({
    x: path[0].x * gridSize,
    y: path[0].y * gridSize,
    pathIndex: 0,
    hp: 10 + level * 2
  });
}

function update() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw path
  path.forEach(p => {
    ctx.drawImage(pathImg, p.x * gridSize, p.y * gridSize, gridSize, gridSize);
  });

  // towers
  towers.forEach(t => {
    ctx.drawImage(towerImg, t.x * gridSize, t.y * gridSize, gridSize, gridSize);
    t.cooldown--;
  });

  // enemies
  enemies.forEach((e, i) => {
    const next = path[e.pathIndex + 1];
    if (next) {
      const tx = next.x * gridSize;
      const ty = next.y * gridSize;
      const dx = tx - e.x;
      const dy = ty - e.y;
      const dist = Math.hypot(dx, dy);

      e.x += dx / dist;
      e.y += dy / dist;

      if (dist < 2) e.pathIndex++;
    } else {
      lives--;
      enemies.splice(i,1);
      updateUI();
    }

    ctx.drawImage(enemyImg, e.x, e.y, gridSize, gridSize);
  });

  // shooting
  towers.forEach(t => {
    if (t.cooldown > 0) return;

    enemies.forEach((e, i) => {
      const dx = e.x - t.x * gridSize;
      const dy = e.y - t.y * gridSize;
      if (Math.hypot(dx, dy) < 120) {
        e.hp -= 5;
        t.cooldown = 30;
        if (e.hp <= 0) {
          enemies.splice(i,1);
          gold += 10;
          updateUI();
        }
      }
    });
  });

  requestAnimationFrame(update);
}

function updateUI() {
  document.getElementById("lives").textContent = lives;
  document.getElementById("gold").textContent = gold;
  document.getElementById("level").textContent = level;
}

setInterval(() => {
  spawnEnemy();
}, Math.max(1200 - level * 50, 400));

setInterval(() => {
  level++;
  updateUI();
}, 15000);

update();
</script>

</body>
</html>
